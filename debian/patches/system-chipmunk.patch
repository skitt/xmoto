Description: Port to Chipmunk2D 7
Author: Stephen Kitt <skitt@debian.org>

--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -85,7 +85,6 @@
   MS_MKDIR
 )
 
-add_subdirectory("${PROJECT_SOURCE_DIR}/vendor/chipmunk" chipmunk)
 add_subdirectory("${PROJECT_SOURCE_DIR}/vendor/md5sum" md5sum)
 add_subdirectory("${PROJECT_SOURCE_DIR}/vendor/glad" glad)
 
--- a/src/xmoto/ScriptDynamicObjects.cpp
+++ b/src/xmoto/ScriptDynamicObjects.cpp
@@ -24,7 +24,7 @@
 #include "xmscene/Entity.h"
 #include "xmscene/Level.h"
 #include "xmscene/Scene.h"
-#include <chipmunk.h>
+#include <chipmunk/chipmunk.h>
 
 SDynamicObject::SDynamicObject(int p_startTime, int p_endTime, int pPeriod) {
   m_time = 0;
@@ -383,7 +383,7 @@
 
   // in the moon buggy example, the author manually update
   // the torque instead of using applyforce, let's do the same
-  body->t += m_torque;
+  cpBodySetTorque(body, cpBodyGetTorque(body) + m_torque);
 }
 
 SPhysicBlockTranslation::SPhysicBlockTranslation(std::string blockName,
@@ -436,5 +436,5 @@
   // apply a force so that the blocks moves of (x,y)
   // TODO::this mult need tweaking
   float mult = 25000.0f;
-  cpBodyApplyForce(body, cpv(x * mult, y * mult), cpvzero);
+  cpBodyApplyForceAtLocalPoint(body, cpv(x * mult, y * mult), cpvzero);
 }
--- a/src/xmscene/Block.cpp
+++ b/src/xmscene/Block.cpp
@@ -30,7 +30,7 @@
 #include "xmoto/GameEvents.h"
 #include "xmoto/PhysSettings.h"
 #include <algorithm>
-#include <chipmunk.h>
+#include <chipmunk/chipmunk.h>
 
 #define XM_DEFAULT_BLOCK_TEXTURE "default"
 #define XM_DEFAULT_PHYS_BLOCK_MASS 30.0
@@ -243,8 +243,7 @@
 }
 
 void Block::setPhysicsPosition(float ix, float iy) {
-  mBody->p.x = ix * CHIP_SCALE_RATIO;
-  mBody->p.y = iy * CHIP_SCALE_RATIO;
+  cpBodySetPosition(mBody, cpv(ix * CHIP_SCALE_RATIO, iy * CHIP_SCALE_RATIO));
 }
 
 void Block::setDynamicPositionAccordingToCenter(
@@ -300,15 +299,16 @@
   // move block according to chipmunk, only if they have moved
   bool moved = false;
 
-  Vector2f newPos = Vector2f(((mBody->p.x) / CHIP_SCALE_RATIO),
-                             (mBody->p.y) / CHIP_SCALE_RATIO);
+  cpVect newVect = cpBodyGetPosition(mBody);
+  Vector2f newPos = Vector2f(newVect.x / CHIP_SCALE_RATIO,
+                             newVect.y / CHIP_SCALE_RATIO);
   if (DynamicPosition() != newPos) {
     setDynamicPosition(newPos);
     moved = true;
   }
 
-  if (DynamicRotation() != mBody->a) {
-    setDynamicRotation(mBody->a);
+  if (DynamicRotation() != cpBodyGetAngle(mBody)) {
+    setDynamicRotation(cpBodyGetAngle(mBody));
     moved = true;
   }
 
@@ -317,7 +317,8 @@
     io_collisionSystem->moveDynBlock(this);
   }
 
-  cpBodyResetForces(mBody);
+  cpBodySetForce(mBody, cpvzero);
+  cpBodySetTorque(mBody, 0);
 }
 
 int Block::loadToPlay(CollisionSystem *io_collisionSystem,
@@ -375,10 +376,9 @@
 
         cpShape *seg =
           cpSegmentShapeNew(i_chipmunkWorld->getBody(), a, b, 0.0f);
-        seg->group = 0;
-        seg->u = m_friction;
-        seg->e = m_elasticity;
-        cpSpaceAddStaticShape(i_chipmunkWorld->getSpace(), seg);
+        cpShapeSetFriction(seg, m_friction);
+        cpShapeSetElasticity(seg, m_elasticity);
+        cpSpaceAddShape(i_chipmunkWorld->getSpace(), seg);
         m_shapes.push_back(seg);
       }
     }
@@ -508,16 +508,18 @@
         cpFloat circle_moment =
           cpMomentForCircle(m_mass, radius, 0.0f, cpvzero);
         myBody = cpBodyNew(m_mass, circle_moment);
-        myBody->p = cpv((DynamicPosition().x * CHIP_SCALE_RATIO),
-                        (DynamicPosition().y * CHIP_SCALE_RATIO));
+        cpBodySetPosition(myBody, cpv((DynamicPosition().x * CHIP_SCALE_RATIO),
+                                      (DynamicPosition().y * CHIP_SCALE_RATIO)));
         cpSpaceAddBody(i_chipmunkWorld->getSpace(), myBody);
         mBody = myBody;
 
         m_shape = cpCircleShapeNew(mBody, radius * CHIP_SCALE_RATIO, cpvzero);
-        m_shape->u = m_friction;
-        m_shape->e = m_elasticity;
+        cpShapeSetFriction(m_shape, m_friction);
+        cpShapeSetElasticity(m_shape, m_elasticity);
         if (isBackground() == true) {
-          m_shape->group = 1;
+          cpShapeFilter filter = cpShapeGetFilter(m_shape);
+          filter.group = 1;
+          cpShapeSetFilter(m_shape, filter);
         }
 
         cpSpaceAddShape(i_chipmunkWorld->getSpace(), m_shape);
@@ -533,13 +535,13 @@
 
         // Create body to attach shapes to
         cpFloat bMoment =
-          cpMomentForPoly(m_mass, Vertices().size(), myVerts, cpvzero);
+          cpMomentForPoly(m_mass, Vertices().size(), myVerts, cpvzero, 0);
         free(myVerts);
 
         // create body
         myBody = cpBodyNew(m_mass, bMoment);
-        myBody->p = cpv((DynamicPosition().x * CHIP_SCALE_RATIO),
-                        (DynamicPosition().y * CHIP_SCALE_RATIO));
+        cpBodySetPosition(myBody, cpv((DynamicPosition().x * CHIP_SCALE_RATIO),
+                                      (DynamicPosition().y * CHIP_SCALE_RATIO)));
         cpSpaceAddBody(i_chipmunkWorld->getSpace(), myBody);
         mBody = myBody;
 
@@ -562,11 +564,14 @@
 
             // collision shape
             m_shape = cpPolyShapeNew(
-              myBody, (*v_BSPPolys)[i]->Vertices().size(), myVerts, cpvzero);
-            m_shape->u = m_friction;
-            m_shape->e = m_elasticity;
+              myBody, (*v_BSPPolys)[i]->Vertices().size(), myVerts,
+              cpTransformIdentity, 0);
+            cpShapeSetFriction(m_shape, m_friction);
+            cpShapeSetElasticity(m_shape, m_elasticity);
             if (isBackground()) {
-              m_shape->group = 1;
+              cpShapeFilter filter = cpShapeGetFilter(m_shape);
+              filter.group = 1;
+              cpShapeSetFilter(m_shape, filter);
             }
 
             cpSpaceAddShape(i_chipmunkWorld->getSpace(), m_shape);
--- a/src/xmscene/ChipmunkWorld.cpp
+++ b/src/xmscene/ChipmunkWorld.cpp
@@ -24,7 +24,7 @@
 #include "PhysicsSettings.h"
 #include "helpers/Log.h"
 #include "xmoto/PhysSettings.h"
-#include <chipmunk.h>
+#include <chipmunk/chipmunk.h>
 
 #define CHIPMUNK_ITERATION 8
 
@@ -35,7 +35,7 @@
 
 ChipmunkWorld::~ChipmunkWorld() {
   for (size_t i = 0;i < m_joints.size();i++) {
-    cpJointFree(m_joints[i]);
+    cpConstraintFree(m_joints[i]);
   }
   for (size_t i = 0;i < m_shapes.size();i++) {
     cpShapeFree(m_shapes[i]);
@@ -60,7 +60,7 @@
 }
 
 void ChipmunkWorld::setGravity(float i_x, float i_y) {
-  m_space->gravity = cpv(i_x * CHIP_GRAVITY_RATIO, i_y * CHIP_GRAVITY_RATIO);
+  cpSpaceSetGravity(m_space, cpv(i_x * CHIP_GRAVITY_RATIO, i_y * CHIP_GRAVITY_RATIO));
 }
 
 void ChipmunkWorld::initPhysics(PhysicsSettings *i_physicsSettings,
@@ -69,19 +69,14 @@
   float v_dm;
   int v_count;
 
-  cpInitChipmunk();
-
   cpSpace *space = cpSpaceNew();
   setSpace(space);
 
-  cpResetShapeIdCounter();
-
   // do need to resolve gravity between ODE and Chipmunk
-  space->gravity =
-    cpv(0.0f, -i_physicsSettings->WorldGravity() * CHIP_GRAVITY_RATIO);
+  cpSpaceSetGravity(space, cpv(0.0f, -i_physicsSettings->WorldGravity() * CHIP_GRAVITY_RATIO));
 
   // static body to 'hang' the ground segments on -- never moves
-  staticBody = cpBodyNew(INFINITY, INFINITY);
+  staticBody = cpBodyNewStatic();
   setBody(staticBody);
 
   // The spatial hashes used by Chipmunkâ€™s collision detection are fairly size
@@ -99,7 +94,7 @@
   v_count = i_level->nbPhysicBlocks() * 10;
 
   resizeHashes(v_dm, v_count);
-  m_space->iterations = CHIPMUNK_ITERATION;
+  cpSpaceSetIterations(m_space, CHIPMUNK_ITERATION);
 
   LogInfo("Chipmunk init : hash (dimension=%.2f, count=%i), iteration=%i",
           v_dm,
@@ -109,8 +104,7 @@
 
 void ChipmunkWorld::resizeHashes(float i_dim, unsigned int i_size) {
   if (m_space != NULL) {
-    cpSpaceResizeActiveHash(m_space, i_dim, i_size);
-    cpSpaceResizeStaticHash(m_space, i_dim, i_size);
+    cpSpaceUseSpatialHash(m_space, i_dim, i_size);
   }
 }
 
@@ -153,8 +147,8 @@
   cpBody *v_wb;
   cpBody *v_wf;
 
-  cpJoint *v_jb;
-  cpJoint *v_jf;
+  cpConstraint *v_jb;
+  cpConstraint *v_jf;
 
   // Wheel mass.. as above ODE/Chipmunk
   cpFloat mass = CHIP_WHEEL_MASS;
@@ -165,8 +159,8 @@
     cpvzero);
   cpShape *shape;
 
-  v_ab = cpBodyNew(INFINITY, INFINITY);
-  v_af = cpBodyNew(INFINITY, INFINITY);
+  v_ab = cpBodyNewKinematic();
+  v_af = cpBodyNewKinematic();
 
   // Create the wheels which will be ODE's surrogates in Chipmunk
   v_wb = cpBodyNew(mass, wheel_moment);
@@ -176,11 +170,11 @@
   cpSpaceAddBody(m_space, v_wb);
   cpSpaceAddBody(m_space, v_wf);
 
-  // Pin-joint the wheels to the anchors
-  v_jb = cpPinJointNew(v_ab, v_wb, cpvzero, cpvzero);
-  v_jf = cpPinJointNew(v_af, v_wf, cpvzero, cpvzero);
-  cpSpaceAddJoint(m_space, v_jb);
-  cpSpaceAddJoint(m_space, v_jf);
+  // Pivot-joint the wheels to the anchors
+  v_jb = cpPivotJointNew(v_ab, v_wb, cpvzero);
+  v_jf = cpPivotJointNew(v_af, v_wf, cpvzero);
+  cpSpaceAddConstraint(m_space, v_jb);
+  cpSpaceAddConstraint(m_space, v_jf);
 
   // creating collision shapes for the wheels
   //   change to collision group 1
@@ -189,9 +183,11 @@
                            i_biker->getPhysicsSettings()->BikeWheelRadius() *
                              CHIP_SCALE_RATIO,
                            cpvzero);
-  shape->u = CHIP_WHEEL_FRICTION;
-  shape->e = CHIP_WHEEL_ELASTICITY;
-  shape->group = 1;
+  cpShapeSetFriction(shape, CHIP_WHEEL_FRICTION);
+  cpShapeSetElasticity(shape, CHIP_WHEEL_ELASTICITY);
+  cpShapeFilter filter = cpShapeGetFilter(shape);
+  filter.group = 1;
+  cpShapeSetFilter(shape, filter);
   cpSpaceAddShape(m_space, shape);
   m_shapes.push_back(shape);
 
@@ -199,9 +195,11 @@
                            i_biker->getPhysicsSettings()->BikeWheelRadius() *
                              CHIP_SCALE_RATIO,
                            cpvzero);
-  shape->u = CHIP_WHEEL_FRICTION;
-  shape->e = CHIP_WHEEL_ELASTICITY;
-  shape->group = 1;
+  cpShapeSetFriction(shape, CHIP_WHEEL_FRICTION);
+  cpShapeSetElasticity(shape, CHIP_WHEEL_ELASTICITY);
+  filter = cpShapeGetFilter(shape);
+  filter.group = 1;
+  cpShapeSetFilter(shape, filter);
   cpSpaceAddShape(m_space, shape);
   m_shapes.push_back(shape);
 
@@ -214,38 +212,41 @@
   m_joints.push_back(v_jf);
 
   /* init position */
-  v_af->p = cpv(i_biker->getState()->FrontWheelP.x * CHIP_SCALE_RATIO,
-                i_biker->getState()->FrontWheelP.y * CHIP_SCALE_RATIO);
-  v_ab->p = cpv(i_biker->getState()->RearWheelP.x * CHIP_SCALE_RATIO,
-                i_biker->getState()->RearWheelP.y * CHIP_SCALE_RATIO);
-  v_wf->p = v_af->p;
-  v_wb->p = v_ab->p;
+  cpBodySetPosition(v_af,
+                    cpv(i_biker->getState()->FrontWheelP.x * CHIP_SCALE_RATIO,
+                        i_biker->getState()->FrontWheelP.y * CHIP_SCALE_RATIO));
+  cpBodySetPosition(v_ab,
+                    cpv(i_biker->getState()->RearWheelP.x * CHIP_SCALE_RATIO,
+                        i_biker->getState()->RearWheelP.y * CHIP_SCALE_RATIO));
+  cpBodySetPosition(v_wf, cpBodyGetPosition(v_af));
+  cpBodySetPosition(v_wb, cpBodyGetPosition(v_ab));
 }
 
 void ChipmunkWorld::updateWheelsPosition(
   const std::vector<Biker *> &i_players) {
   cpBody *b;
   cpFloat dx, dy;
+  cpVect pos;
 
   for (unsigned int i = 0; i < i_players.size(); i++) {
     // inform chipmunk of ODE pos of front wheel
     b = getFrontWheel(i);
 
-    b->w = i_players[i]->getFrontWheelVelocity();
-    dx = i_players[i]->getState()->FrontWheelP.x * CHIP_SCALE_RATIO - b->p.x;
-    dy = i_players[i]->getState()->FrontWheelP.y * CHIP_SCALE_RATIO - b->p.y;
+    cpBodySetAngularVelocity(b, i_players[i]->getFrontWheelVelocity());
+    pos = cpBodyGetPosition(b);
+    dx = i_players[i]->getState()->FrontWheelP.x * CHIP_SCALE_RATIO - pos.x;
+    dy = i_players[i]->getState()->FrontWheelP.y * CHIP_SCALE_RATIO - pos.y;
 
-    b->p.x += dx / CHIP_WHEEL_DAMPENING;
-    b->p.y += dy / CHIP_WHEEL_DAMPENING;
+    cpBodySetPosition(b, cpv(pos.x + dx/CHIP_WHEEL_DAMPENING, pos.y + dy/CHIP_WHEEL_DAMPENING));
 
     // inform chipmunk of ODE pos of back wheel
     b = getBackWheel(i);
 
-    b->w = i_players[i]->getRearWheelVelocity();
-    dx = i_players[i]->getState()->RearWheelP.x * CHIP_SCALE_RATIO - b->p.x;
-    dy = i_players[i]->getState()->RearWheelP.y * CHIP_SCALE_RATIO - b->p.y;
+    cpBodySetAngularVelocity(b, i_players[i]->getRearWheelVelocity());
+    pos = cpBodyGetPosition(b);
+    dx = i_players[i]->getState()->RearWheelP.x * CHIP_SCALE_RATIO - pos.x;
+    dy = i_players[i]->getState()->RearWheelP.y * CHIP_SCALE_RATIO - pos.y;
 
-    b->p.x += dx / CHIP_WHEEL_DAMPENING;
-    b->p.y += dy / CHIP_WHEEL_DAMPENING;
+    cpBodySetPosition(b, cpv(pos.x + dx/CHIP_WHEEL_DAMPENING, pos.y + dy/CHIP_WHEEL_DAMPENING));
   }
 }
--- a/src/xmscene/Entity.cpp
+++ b/src/xmscene/Entity.cpp
@@ -30,7 +30,7 @@
 #include "helpers/Log.h"
 #include "helpers/Random.h"
 #include "xmoto/PhysSettings.h"
-#include <chipmunk.h>
+#include <chipmunk/chipmunk.h>
 #include <sstream>
 
 // don't excceed this number of particles to not reduce significantly the fps
@@ -621,8 +621,8 @@
 
   // we don't want them to collide. if a block is already attached to
   // a joint, reuse its collision group
-  int group1 = getStartBlock()->getPhysicShape()->group;
-  int group2 = getEndBlock()->getPhysicShape()->group;
+  int group1 = cpShapeGetFilter(getStartBlock()->getPhysicShape()).group;
+  int group2 = cpShapeGetFilter(getEndBlock()->getPhysicShape()).group;
   int group;
   // we don't handle the case where the two blocks are already
   // attached to other joints and already have a group.
@@ -639,10 +639,16 @@
   }
 
   // update only if not background block
-  if (group1 != 1)
-    getStartBlock()->getPhysicShape()->group = group;
-  if (group2 != 1)
-    getEndBlock()->getPhysicShape()->group = group;
+  if(group1 != 1) {
+    cpShapeFilter filter = cpShapeGetFilter(getStartBlock()->getPhysicShape());
+    filter.group = group;
+    cpShapeSetFilter(getStartBlock()->getPhysicShape(), filter);
+  }
+  if(group2 != 1) {
+    cpShapeFilter filter = cpShapeGetFilter(getEndBlock()->getPhysicShape());
+    filter.group = group;
+    cpShapeSetFilter(getEndBlock()->getPhysicShape(), filter);
+  }
 
   switch (getJointType()) {
     case Pivot:
@@ -650,12 +656,12 @@
       v.x = DynamicPosition().x * CHIP_SCALE_RATIO;
       v.y = DynamicPosition().y * CHIP_SCALE_RATIO;
 
-      cpSpaceAddJoint(i_chipmunkWorld->getSpace(),
-                      cpPivotJointNew(body1, body2, v));
+      cpSpaceAddConstraint(i_chipmunkWorld->getSpace(),
+                           cpPivotJointNew(body1, body2, v));
       break;
     case Pin:
-      cpSpaceAddJoint(i_chipmunkWorld->getSpace(),
-                      cpPinJointNew(body1, body2, cpvzero, cpvzero));
+      cpSpaceAddConstraint(i_chipmunkWorld->getSpace(),
+                           cpPinJointNew(body1, body2, cpvzero, cpvzero));
       break;
     case JointNone:
     default:
--- a/src/xmscene/Level.cpp
+++ b/src/xmscene/Level.cpp
@@ -41,7 +41,7 @@
 #include "helpers/Log.h"
 #include "helpers/Text.h"
 #include "xmoto/Collision.h"
-#include <chipmunk.h>
+#include <chipmunk/chipmunk.h>
 
 Level::Level() {
   m_xmotoTooOld = false;
--- a/src/xmscene/ChipmunkWorld.h
+++ b/src/xmscene/ChipmunkWorld.h
@@ -25,7 +25,7 @@
 
 class cpSpace;
 class cpBody;
-class cpJoint;
+class cpConstraint;
 class cpShape;
 class PlayerLocalBiker;
 class Biker;
@@ -61,7 +61,7 @@
   std::vector<cpBody *> m_af;
   std::vector<cpBody *> m_wb; // wheel bodies
   std::vector<cpBody *> m_wf;
-  std::vector<cpJoint *> m_joints;
+  std::vector<cpConstraint *> m_joints;
   std::vector<cpShape *> m_shapes;
 };
 
